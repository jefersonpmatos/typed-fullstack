/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * TYPED FULL STACK
 * Description
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  CreateUser201,
  CreateUser400,
  CreateUser409,
  CreateUser500,
  CreateUserBody,
  LoginUser200,
  LoginUser400,
  LoginUser404,
  LoginUser500,
  LoginUserBody,
  LogoutUser200,
  LogoutUser400,
  LogoutUser404,
  LogoutUser500
} from './api.schemas';






/**
 * Register a new user
 * @summary Register
 */
export const getCreateUserUrl = () => {


  

  return `http://localhost:3333/auth/register`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<CreateUser201> => {
  
  const res = await fetch(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: CreateUser201 = body ? JSON.parse(body) : {}

  return data
}




export const getCreateUserMutationOptions = <TError = CreateUser400 | CreateUser409 | CreateUser500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = CreateUser400 | CreateUser409 | CreateUser500

    /**
 * @summary Register
 */
export const useCreateUser = <TError = CreateUser400 | CreateUser409 | CreateUser500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Login user
 * @summary Login
 */
export const getLoginUserUrl = () => {


  

  return `http://localhost:3333/auth/login`
}

export const loginUser = async (loginUserBody: LoginUserBody, options?: RequestInit): Promise<LoginUser200> => {
  
  const res = await fetch(getLoginUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: LoginUser200 = body ? JSON.parse(body) : {}

  return data
}




export const getLoginUserMutationOptions = <TError = LoginUser400 | LoginUser404 | LoginUser500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginUserBody}, TContext> => {

const mutationKey = ['loginUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginUser>>, {data: LoginUserBody}> = (props) => {
          const {data} = props ?? {};

          return  loginUser(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginUserMutationResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>
    export type LoginUserMutationBody = LoginUserBody
    export type LoginUserMutationError = LoginUser400 | LoginUser404 | LoginUser500

    /**
 * @summary Login
 */
export const useLoginUser = <TError = LoginUser400 | LoginUser404 | LoginUser500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginUserBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginUser>>,
        TError,
        {data: LoginUserBody},
        TContext
      > => {

      const mutationOptions = getLoginUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Logout user
 * @summary Logout
 */
export const getLogoutUserUrl = () => {


  

  return `http://localhost:3333/auth/logout`
}

export const logoutUser = async ( options?: RequestInit): Promise<LogoutUser200> => {
  
  const res = await fetch(getLogoutUserUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: LogoutUser200 = body ? JSON.parse(body) : {}

  return data
}




export const getLogoutUserMutationOptions = <TError = LogoutUser400 | LogoutUser404 | LogoutUser500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutUser>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof logoutUser>>, TError,void, TContext> => {

const mutationKey = ['logoutUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutUser>>, void> = () => {
          

          return  logoutUser(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutUserMutationResult = NonNullable<Awaited<ReturnType<typeof logoutUser>>>
    
    export type LogoutUserMutationError = LogoutUser400 | LogoutUser404 | LogoutUser500

    /**
 * @summary Logout
 */
export const useLogoutUser = <TError = LogoutUser400 | LogoutUser404 | LogoutUser500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutUser>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logoutUser>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    